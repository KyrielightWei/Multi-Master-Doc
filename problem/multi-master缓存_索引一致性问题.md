## 问题描述

共享存储架构要求每个节点都必须有对存储层上所有数据的完整的索引，这是多节点读写的前提。

而节点执行更新、插入、删除操作时，都需要对索引进行更新，如何让其它节点获知索引的变更并更新自己的本地索引？这是研究缓存一致性过程中必须解决的问题。

## 可能的解决方案

### 方案一 日志流

在一写多读的场景下，无论是polarDB还是Aurora都采用了日志流的方式进行节点间缓存的同步，即写节点在执行写操作的同时将日志发送给其余各个读节点，读节点根据日志流进行回放，同步更新本地缓存，以此达到多节点缓存一致的目的。日志回放的过程中也更新缓存中的索引，由此达成索引的同步更新。

但这一方案在多写场景下会面临多个日志流同时发送带来的日志序号混乱的问题，而维护全局的日志序号又会带来性能上的开销和扩展性上的瓶颈。并且，PolarDB的存储层不支持日志回放这一局限性，使得我们无法在存储层对日志进行全局排序后回放（Hyder和Aurora的方案）。

### 方案二 锁

在RAC的方案中，将数据与索引一视同仁的使用分布式锁进行上锁，解决了多节点更新的冲突。但索引与数据具有不同的特性：

1. 索引是广泛存在于每个节点的，数据具有局部性，一个节点修改的数据未必存在于所有节点
2. 相比于数据的单位——行，一个页中可以包含更多的索引项，在页的层面上产生的冲突更为剧烈
3. 对同一个表的末尾执行插入操作，在逻辑上是不冲突的（数据页层面上可能也不会产生冲突），但索引的更新需要更新b树右下角的叶节点，这会引起冲突

在RAC的技术报告中也有提到：**99%的OLTP性能问题，发生在索引的写热点**

因此，在锁的方案中，将索引和数据区别对待，是否会带来更大的性能收益？这一问题值得后续探讨。

